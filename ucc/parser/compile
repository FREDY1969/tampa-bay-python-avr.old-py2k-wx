#!/usr/bin/python

# compile

# compile project_dir

from __future__ import with_statement

import sys
import os, os.path
import contextlib
import traceback
import sqlite3 as db

QA_db_filename = 'python-avr.db'

python_path = os.path.abspath(os.path.join(os.path.dirname(__file__),
                                           '..', '..'))
print "python_path", python_path

if sys.path[0] == '': sys.path[0] = python_path
else: sys.path.insert(0, python_path)

from ucc.word import helpers
from ucc.parser import genparser
from ucc.ast import ast

def usage():
    sys.stderr.write("usage: compile project_dir\n")
    sys.exit(2)

def run():
    if len(sys.argv) != 2: usage()

    project_dir = sys.argv[1]

    # Figure out python package name for project.
    abs_project_dir = os.path.abspath(project_dir)
    assert abs_project_dir.startswith(python_path)
    project_pkg = abs_project_dir[len(python_path) + 1:] \
                    .replace(os.path.sep, '.')
    if os.path.sep != '/': project_pkg.replace('/', '.')

    # Gather words_by_name, words_by_id, rules and token_dict:
    with contextlib.closing(db.connect(os.path.join(project_dir,
                                                    QA_db_filename))) \
      as db_conn:
        with contextlib.closing(db_conn.cursor()) as db_cur:
            mod = import_module(project_pkg + '.declaration')
            decl = getattr(mod, 'declaration')
            decl.init_class('declaration', 1, db_cur)
            words_by_name = {'declaration': decl}
            words_by_id = {decl.kind_id: decl}
            rules = ()
            token_dict = {}
            db_cur.execute("""select id, name, kind, defining_word
                                from word
                               where name != 'declaration'
                               order by defining_word desc""")
            for id, name, kind, defining_word in db_cur.fetchall():
                #print "id, name, kind, defining_word", id, name, kind, defining_word
                if defining_word:
                    mod_name = helpers.legalize_name(name)
                    mod = import_module(project_pkg + '.' + mod_name)
                    new_word = getattr(mod, mod_name)
                    new_word.init_class(name, id, db_cur)
                else:
                    new_word = words_by_id[kind](name, id)
                    r, td = new_word.new_syntax(db_cur)
                    rules += r
                    token_dict.update(td)
                words_by_name[name] = new_word
                words_by_id[id] = new_word

    #print "rules", rules
    #print "token_dict", token_dict

    # compile new parser for this project:
    with open(os.path.join(project_dir, 'parser.py'), 'w') as output_file:
        genparser.genparser(os.path.join(os.path.dirname(__file__), 'SYNTAX'),
                            '\n'.join(rules), token_dict, output_file)

    # import needed modules from the project:
    parser = import_module(project_pkg + '.parser')

    # parse files in the project:
    num_errors = 0
    with ast.db_connection(project_dir):
        for word_obj in words_by_id.itervalues():
            try:
                if not isinstance(word_obj, type): # word_obj not a class
                    word_obj.parse_file(parser, project_dir)
            except SyntaxError:
                e_type, e_value, e_tb = sys.exc_info()
                for line in traceback.format_exception_only(e_type, e_value):
                    sys.stderr.write(line)
                num_errors += 1
            except Exception:
                traceback.print_exc()
                num_errors += 1
    if num_errors:
        sys.exit(1)

def import_module(modulename):
    ''' modulename is full package path (with dots) and does not include .py.
    '''
    mod = __import__(modulename)
    for comp in modulename.split('.')[1:]:
        mod = getattr(mod, comp)
    return mod

if __name__ == "__main__":
    run()
